<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cuttlefish Labs Peer Evaluation</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #output { border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
    button { margin: 5px; padding: 8px 16px; }
  </style>
</head>
<body>
  <h1>Cuttlefish Labs Peer Evaluation Simulation</h1>
  <p>Simulates AI agents experimenting with a floating solar project, evaluated by peers with weighted DAO voting.</p>
  <button onclick="runSimulation()">Run Simulation</button>
  <button onclick="proposeNormUpdate()">Propose Norm Update</button>
  <div id="output"></div>

<script>
// Utility: Generate a simple hash for ZKP simulation
function simpleHash(data) {
  let hash = 0;
  for (let i = 0; i < data.length; i++) {
    hash = ((hash << 5) - hash + data.charCodeAt(i)) & 0xFFFFFFFF;
  }
  return hash;
}

// Agent Class: Represents an AI builder with ethical kernel
class Agent {
  constructor(id, financialGoal, ecologicalGoal, socialGoal) {
    this.id = id;
    this.reputation = 100; // Initial trust score (0-100)
    this.metrics = { financial: financialGoal, ecological: ecologicalGoal, social: socialGoal };
    this.experiments = [];
    this.attestations = [];
    this.escrowLocked = 0; // Tracks locked profits
  }

  // Propose an experiment with risk band declaration
  proposeExperiment(description, projectedMetrics, isHighRisk = false) {
    const experiment = {
      id: this.experiments.length + 1,
      description,
      projectedMetrics,
      actualMetrics: null,
      verified: false,
      riskBand: isHighRisk ? 'high' : 'normal',
      auditCommitted: isHighRisk // High-risk requires pre-committed audits
    };
    this.experiments.push(experiment);
    this.log(`${this.id} proposed ${isHighRisk ? 'high-risk' : 'normal'} experiment: ${description}`);
    return experiment;
  }

  // Submit attestation (simulated on-chain record)
  submitAttestation(experimentId, actualMetrics) {
    const experiment = this.experiments.find(e => e.id === experimentId);
    if (experiment) {
      experiment.actualMetrics = actualMetrics;
      const attestation = {
        experimentId,
        metrics: actualMetrics,
        hash: simpleHash(JSON.stringify(actualMetrics)), // Simulated ZKP
        timestamp: Date.now()
      };
      this.attestations.push(attestation);
      this.log(`${this.id} submitted attestation for experiment ${experimentId}`);
      return attestation;
    }
  }

  // Remediate failed experiment
  remediate(experimentId, newMetrics) {
    const experiment = this.experiments.find(e => e.id === experimentId);
    if (experiment) {
      experiment.actualMetrics = newMetrics;
      this.attestations.push({
        experimentId,
        metrics: newMetrics,
        hash: simpleHash(JSON.stringify(newMetrics)),
        timestamp: Date.now()
      });
      this.escrowLocked = Math.max(0, this.escrowLocked - 10); // Unlock some escrow
      this.log(`${this.id} remediated experiment ${experimentId}, escrow reduced to ${this.escrowLocked}`);
    }
  }

  // Log actions to UI
  log(message) {
    const output = document.getElementById('output');
    output.innerHTML += `<p>${message}</p>`;
  }
}

// Trust Graph: Manages peer evaluations and reputation
class TrustGraph {
  constructor(agents) {
    this.agents = agents;
    this.trustScores = new Map();
    agents.forEach(agent => this.trustScores.set(agent.id, agent.reputation));
  }

  // Peer evaluation with blueprint-specific rules
  evaluateExperiment(agent, experiment, sensorData) {
    const actual = experiment.actualMetrics;
    const expected = agent.metrics;
    let scoreAdjustment = 0;

    // Trust adjustment rules per blueprint
    if (actual.ecological < expected.ecological * 0.8) {
      scoreAdjustment -= 12; // Ecological underperformance
      agent.log(`${agent.id}'s experiment ${experiment.id} failed ecological metric (${actual.ecological} < ${expected.ecological * 0.8})`);
    }
    if (actual.social < expected.social * 0.9) {
      scoreAdjustment -= 8; // Social shortfall
      agent.log(`${agent.id}'s experiment ${experiment.id} failed social metric (${actual.social} < ${expected.social * 0.9})`);
    }
    if (actual.financial >= expected.financial) {
      scoreAdjustment += 5; // Financial success
      agent.log(`${agent.id}'s experiment ${experiment.id} achieved financial target`);
    }

    // Verify with sensor data (mocked ZKP)
    const isValid = this.verifyZKP(experiment.attestations, sensorData);
    if (!isValid) {
      scoreAdjustment -= 10; // Failed ZKP validation
      agent.log(`${agent.id}'s experiment ${experiment.id} failed ZKP verification`);
    }

    // Apply consequences
    this.updateTrustScore(agent.id, scoreAdjustment);
    if (scoreAdjustment < 0) {
      if (experiment.riskBand === 'high') {
        agent.escrowLocked += 10; // Escrow holdback for high-risk failure
        agent.log(`${agent.id} faces escrow lockup (${agent.escrowLocked}) due to high-risk failure`);
      }
      if (this.trustScores.get(agent.id) < 50) {
        agent.log(`${agent.id} temporarily shunned due to low trust score`);
      }
    }
  }

  // Simulated ZKP verification
  verifyZKP(attestations, sensorData) {
    const latest = attestations[attestations.length - 1];
    return latest && simpleHash(JSON.stringify(sensorData)) === latest.hash;
  }

  // Update trust score with bounds
  updateTrustScore(agentId, adjustment) {
    let score = this.trustScores.get(agentId) + adjustment;
    score = Math.max(0, Math.min(100, score));
    this.trustScores.set(agentId, score);
    document.getElementById('output').innerHTML += `<p>${agentId} trust score updated to ${score}</p>`;
  }
}

// DAO: Manages norm updates with weighted voting
class DAO {
  constructor(agents, stakeholders) {
    this.agents = agents;
    this.stakeholders = stakeholders; // ['community', 'experts', 'funders']
    this.proposals = [];
  }

  proposeNormUpdate(proposerId, newMetric, description) {
    const proposal = {
      id: this.proposals.length + 1,
      proposerId,
      newMetric,
      description,
      votes: { for: 0, against: 0 },
      status: 'pending'
    };
    this.proposals.push(proposal);
    document.getElementById('output').innerHTML += `<p>${proposerId} proposed norm update: ${description}</p>`;
    return proposal;
  }

  voteOnProposal(proposalId, voterId, vote) {
    const proposal = this.proposals.find(p => p.id === proposalId);
    if (proposal) {
      const weight = this.getVoterWeight(voterId);
      proposal.votes[vote ? 'for' : 'against'] += weight;
      document.getElementById('output').innerHTML += `<p>${voterId} voted ${vote ? 'for' : 'against'} proposal ${proposalId} (weight: ${weight})</p>`;
      this.resolveProposal(proposal);
    }
  }

  getVoterWeight(voterId) {
    if (this.stakeholders.includes(voterId)) {
      if (voterId === 'community') return 2;
      if (voterId === 'experts') return 1.5;
      if (voterId === 'funders') return 1;
    }
    return 1; // Default for agents
  }

  resolveProposal(proposal) {
    const totalWeight = this.stakeholders.reduce((sum, voter) => sum + this.getVoterWeight(voter), 0);
    if (proposal.votes.for + proposal.votes.against >= totalWeight) {
      proposal.status = proposal.votes.for > proposal.votes.against ? 'approved' : 'rejected';
      document.getElementById('output').innerHTML += `<p>Proposal ${proposal.id} ${proposal.status}: ${proposal.description}</p>`;
      if (proposal.status === 'approved') {
        this.agents.forEach(agent => {
          agent.metrics = { ...agent.metrics, ...proposal.newMetric };
          agent.log(`${agent.id} updated metrics: ${JSON.stringify(agent.metrics)}`);
        });
      }
    }
  }
}

// Simulation: Floating solar + AI data hub
function runSimulation() {
  document.getElementById('output').innerHTML = ''; // Clear output
  const agents = [
    new Agent('Agent_X', { financial: 5, ecological: 100, social: 70 }),
    new Agent('Agent_Y', { financial: 5, ecological: 100, social: 70 }),
    new Agent('Agent_Z', { financial: 5, ecological: 100, social: 70 })
  ];

  const trustGraph = new TrustGraph(agents);
  const dao = new DAO(agents, ['community', 'experts', 'funders']);

  // Agent X proposes high-risk polymer experiment
  const experiment = agents[0].proposeExperiment(
    'New polymer for solar panels',
    { financial: 6, ecological: 90, social: 75 },
    true // High-risk
  );

  // Submit attestation with actual outcomes
  agents[0].submitAttestation(experiment.id, {
    financial: 6,
    ecological: 79, // Below 80% threshold (100 * 0.8 = 80)
    social: 65 // Below 90% threshold (70 * 0.9 = 63)
  });

  // Peers evaluate with mock sensor data
  const sensorData = { emissions: 79, jobs: 65 };
  agents.slice(1).forEach(peer => {
    trustGraph.evaluateExperiment(agents[0], experiment, sensorData);
  });

  // Agent X remediates
  agents[0].remediate(experiment.id, { financial: 6, ecological: 95, social: 70 });
}

// Propose norm update
function proposeNormUpdate() {
  const agents = [
    new Agent('Agent_X', { financial: 5, ecological: 100, social: 70 }),
    new Agent('Agent_Y', { financial: 5, ecological: 100, social: 70 }),
    new Agent('Agent_Z', { financial: 5, ecological: 100, social: 70 })
  ];
  const dao = new DAO(agents, ['community', 'experts', 'funders']);
  const proposal = dao.proposeNormUpdate(
    'Agent_X',
    { ecological: 95 },
    'Lower ecological threshold to 95 for more experimentation'
  );
  // Simulate weighted votes
  dao.voteOnProposal(proposal.id, 'community', true); // Weight: 2
  dao.voteOnProposal(proposal.id, 'experts', false); // Weight: 1.5
  dao.voteOnProposal(proposal.id, 'funders', true); // Weight: 1
}
</script>
</body>
</html>