// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

contract BuilderAgentWallet is Ownable {
    address public agentID;
    mapping(address => uint256) public tokenHoldings;
    mapping(address => bool) public approvedDAOContracts;
    address public reputationContract;

    event TokenDeposited(address indexed token, uint256 amount);
    event TokenWithdrawn(address indexed token, uint256 amount);
    event ProposalSubmitted(address indexed daoContract, uint256 proposalID);
    event ExternalInvestment(address indexed token, uint256 amount, string targetProtocol);

    struct SimulationResult {
        bool eligible;
        uint256 score;
        string message;
    }

    modifier onlyAgent() {
        require(msg.sender == agentID, "Not authorized AI agent");
        _;
    }

    modifier reputationAbove(uint256 threshold) {
        require(getReputationScore() >= threshold, "Reputation too low");
        _;
    }

    constructor(address _agentID) {
        require(_agentID != address(0), "Invalid agent ID");
        agentID = _agentID;
        transferOwnership(msg.sender); // safer than tx.origin
    }

    function depositToken(address token, uint256 amount) external {
        require(token != address(0), "Invalid token address");
        require(amount > 0, "Amount must be greater than zero");
        require(IERC20(token).transferFrom(msg.sender, address(this), amount), "Transfer failed");
        tokenHoldings[token] += amount;
        emit TokenDeposited(token, amount);
    }

    function withdrawToken(address token, uint256 amount) external onlyOwner {
        require(token != address(0), "Invalid token address");
        require(amount > 0, "Amount must be greater than zero");
        require(tokenHoldings[token] >= amount, "Insufficient balance");
        tokenHoldings[token] -= amount;
        require(IERC20(token).transfer(msg.sender, amount), "Withdrawal failed");
        emit TokenWithdrawn(token, amount);
    }

    function approveDAO(address dao) external onlyOwner {
        require(dao != address(0), "Invalid DAO address");
        approvedDAOContracts[dao] = true;
    }

    function submitProposal(address dao, bytes calldata data) external onlyAgent reputationAbove(600) {
        require(dao != address(0), "Invalid DAO address");
        require(approvedDAOContracts[dao], "DAO not approved");
        (bool success, ) = dao.call(data);
        require(success, "Proposal submission failed");
        emit ProposalSubmitted(dao, uint256(uint160(address(this))));
    }

    function setReputationContract(address _reputationContract) external onlyOwner {
        require(_reputationContract != address(0), "Invalid reputation contract");
        reputationContract = _reputationContract;
    }

    function getReputationScore() public view returns (uint256) {
        if (reputationContract == address(0)) return 0;
        (bool success, bytes memory result) = reputationContract.staticcall(abi.encodeWithSignature("getAgentScore(address)", address(this)));
        if (!success) return 0;
        return abi.decode(result, (uint256));
    }

    // SIMULATION FUNCTION: Estimate impact of a proposal based on score threshold
    function simulateProposalImpact(address dao, uint256 scoreThreshold) external view returns (SimulationResult memory) {
        require(dao != address(0), "Invalid DAO address");
        uint256 score = getReputationScore();
        SimulationResult memory result;

        if (!approvedDAOContracts[dao]) {
            result = SimulationResult(false, score, "DAO not approved");
        } else if (score < scoreThreshold) {
            result = SimulationResult(false, score, "Agent reputation score too low to submit proposal");
        } else {
            result = SimulationResult(true, score, "Simulation passed: Agent eligible for DAO proposal");
        }

        return result;
    }

    // SIMULATION FUNCTION: Forecast staking rewards based on balance and APY
    function forecastStakingRewards(address token, uint256 annualRateBP, uint256 months) external view returns (uint256 projectedReward) {
        uint256 principal = tokenHoldings[token];
        require(principal > 0, "No token holdings");
        // Simple interest formula: reward = P * r * t
        projectedReward = (principal * annualRateBP * months) / (12 * 10000);
        return projectedReward;
    }

    // SIMULATION FUNCTION: Calculate reward multiplier based on reputation tiers
    function rewardMultiplier(uint256 baseReward) public view returns (uint256) {
        uint256 score = getReputationScore();
        uint256 multiplier;

        if (score >= 900) {
            multiplier = 150; // 1.5x
        } else if (score >= 750) {
            multiplier = 125; // 1.25x
        } else if (score >= 600) {
            multiplier = 110; // 1.1x
        } else {
            multiplier = 100; // 1.0x
        }

        return (baseReward * multiplier) / 100;
    }

    // FUNCTION: Make external investments based on sustainability motivation
    function investInSustainableProtocol(address token, uint256 amount, string memory targetProtocol) external onlyAgent reputationAbove(700) {
        require(token != address(0), "Invalid token address");
        require(amount > 0, "Amount must be greater than zero");
        require(tokenHoldings[token] >= amount, "Insufficient funds");
        tokenHoldings[token] -= amount;
        emit ExternalInvestment(token, amount, targetProtocol);
        // This is a placeholder for logic interfacing with external DeFi protocols
    }
}
