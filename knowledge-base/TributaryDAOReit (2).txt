// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./GoldenNFT.sol";
import "./CarbonVault.sol";
import "./E2RToken.sol";

contract TributaryDAOReit is Ownable {
    GoldenNFT public goldenNFT;
    CarbonVault public carbonVault;
    E2RToken public e2rToken;
    mapping(uint256 => uint256) public nftVotingPower; // Voting power per NFT
    mapping(address => uint256) public votes; // Total votes per address
    mapping(uint256 => bool) public proposals; // Proposal IDs and status
    mapping(uint256 => uint256) public votesUsedPerProposal; // Track votes per proposal
    uint256 public totalVotes;

    event NFTMinted(uint256 tokenId, address owner, uint256 votingPower);
    event ProposalCreated(uint256 proposalId);
    event VoteCast(address voter, uint256 proposalId, uint256 votes);
    event PayoutDistributed(address to, uint256 e2rAmount, uint256 carbonAmount);

    constructor(address _nftAddress, address _vaultAddress, address _e2rAddress) Ownable(msg.sender) {
        goldenNFT = GoldenNFT(_nftAddress);
        carbonVault = CarbonVault(_vaultAddress);
        e2rToken = E2RToken(_e2rAddress);
    }

    function mintGoldenNFT(address to, string memory uri, string memory tier) external onlyOwner {
        uint256 tokenId = goldenNFT.mint(to, uri, tier);
        uint256 votingPower = _calculateVotingPower(tier);
        nftVotingPower[tokenId] = votingPower;
        votes[to] += votingPower;
        totalVotes += votingPower;
        emit NFTMinted(tokenId, to, votingPower);
    }

    function _calculateVotingPower(string memory tier) internal pure returns (uint256) {
        if (keccak256(abi.encodePacked(tier)) == keccak256(abi.encodePacked("Gold"))) return 150; // 1.5x
        if (keccak256(abi.encodePacked(tier)) == keccak256(abi.encodePacked("Silver"))) return 100; // 1x
        return 50; // Bronze
    }

    function createProposal(uint256 proposalId) external onlyOwner {
        proposals[proposalId] = false; // Open for voting
        emit ProposalCreated(proposalId);
    }

    function castVote(uint256 proposalId, uint256 voteAmount) external {
        require(proposals[proposalId] == false, "Proposal closed or invalid");
        require(voteAmount <= votes[msg.sender], "Not enough voting power");
        votes[msg.sender] -= voteAmount;
        votesUsedPerProposal[proposalId] += voteAmount;
        emit VoteCast(msg.sender, proposalId, voteAmount);
    }

    function finalizeProposal(uint256 proposalId) external onlyOwner {
        require(proposals[proposalId] == false, "Already finalized");
        if (votesUsedPerProposal[proposalId] > totalVotes / 2) {
            proposals[proposalId] = true;
            _distributePayout(proposalId);
        } else {
            proposals[proposalId] = false; // Failed
        }
    }

    function _distributePayout(uint256 milestoneId) internal {
        uint256 payoutAmount = e2rToken.balanceOf(address(this)) / 10; // 10% of E2R treasury
        uint256 carbonAmount = 50 * 10**18; // Example: 50 carbon credits
        if (payoutAmount > 0) {
            e2rToken.triggerPayout(owner(), payoutAmount, milestoneId);
            carbonVault.sellCredits(address(0xBCTorC3T), carbonAmount, owner()); // Carbon payout
            emit PayoutDistributed(owner(), payoutAmount, carbonAmount);
        }
    }

    function getCarbonTreasury() external view returns (address[] memory, uint256[] memory) {
        return carbonVault.getCarbonTreasury();
    }
}